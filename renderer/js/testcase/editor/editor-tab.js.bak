// 编辑器标签 - 单个标签的编辑器实例
// 支持文本和块两种渲染模式，基于统一的数据模型

class EditorTab {
    constructor(container, editorManager) {
        this.container = container;
        this.editorManager = editorManager; // 保存管理器引用
        this.currentMode = editorManager ? editorManager.getGlobalEditMode() : 'block'; // 从管理器读取模式
        this.buffer = null; // 基于TKE的编辑器缓冲区
        this.listeners = [];
        this.saveTimeout = null;
        this.isTestRunning = false;
        this.currentHighlightedLine = null; // 跟踪当前高亮的行号
        this.uniqueId = `editor-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; // 生成唯一ID
        
        // 块定义
        this.blockDefinitions = {
            application: {
                color: '#c586c0',
                icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M16.56,5.44L15.11,6.89C16.84,7.94 18,9.83 18,12A6,6 0 0,1 12,18A6,6 0 0,1 6,12C6,9.83 7.16,7.94 8.88,6.88L7.44,5.44C5.36,6.88 4,9.28 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12C20,9.28 18.64,6.88 16.56,5.44M13,3H11V13H13"/></svg>',
                commands: [
                    { 
                        type: 'launch', 
                        label: '启动', 
                        tksCommand: '启动',
                        params: [
                            { name: 'package', type: 'text', placeholder: '包名', default: 'com.example.test_toolkit' },
                            { name: 'activity', type: 'text', placeholder: 'Activity名字', default: '.MainActivity' }
                        ]
                    },
                    { 
                        type: 'close', 
                        label: '关闭',
                        tksCommand: '关闭',
                        params: [
                            { name: 'package', type: 'text', placeholder: '包名', default: 'com.example.app' },
                            { name: 'activity', type: 'text', placeholder: 'Activity名字', default: '.MainActivity' }
                        ]
                    }
                ]
            },
            action: {
                color: '#569cd6',
                icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 14a8 8 0 0 1-8 8"/><path d="M18 11v-1a2 2 0 0 0-2-2a2 2 0 0 0-2 2"/><path d="M14 10V9a2 2 0 0 0-2-2a2 2 0 0 0-2 2v1"/><path d="M10 9.5V4a2 2 0 0 0-2-2a2 2 0 0 0-2 2v10"/><path d="M18 11a2 2 0 1 1 4 0v3a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>',
                commands: [
                    { 
                        type: 'click', 
                        label: '点击',
                        tksCommand: '点击',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML/图片元素', default: '' }
                        ]
                    },
                    { 
                        type: 'press', 
                        label: '按压',
                        tksCommand: '按压',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML/图片元素', default: '' },
                            { name: 'duration', type: 'number', placeholder: '持续时长/ms', default: '1000' }
                        ]
                    },
                    { 
                        type: 'swipe', 
                        label: '滑动',
                        tksCommand: '滑动',
                        params: [
                            { name: 'startPoint', type: 'coordinate', placeholder: '起点坐标', default: '{200,400}' },
                            { name: 'endPoint', type: 'coordinate', placeholder: '终点坐标', default: '{300,600}' },
                            { name: 'duration', type: 'number', placeholder: '持续时长/ms', default: '1000' }
                        ]
                    },
                    { 
                        type: 'drag', 
                        label: '拖动',
                        tksCommand: '拖动',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML/图片元素', default: '' },
                            { name: 'endPoint', type: 'coordinate', placeholder: '终点坐标', default: '{500,800}' },
                            { name: 'duration', type: 'number', placeholder: '持续时长/ms', default: '1000' }
                        ]
                    },
                    { 
                        type: 'directional_drag', 
                        label: '定向拖动',
                        tksCommand: '定向拖动',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML/图片元素', default: '' },
                            { name: 'direction', type: 'select', placeholder: '方向', default: 'up', options: ['up', 'down', 'left', 'right'] },
                            { name: 'distance', type: 'number', placeholder: '拖动距离', default: '300' },
                            { name: 'duration', type: 'number', placeholder: '持续时长/ms', default: '1000' }
                        ]
                    }
                ]
            },
            input: {
                color: '#4ec9b0',
                icon: '⌨',
                commands: [
                    { 
                        type: 'input', 
                        label: '输入',
                        tksCommand: '输入',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML元素', default: '' },
                            { name: 'text', type: 'text', placeholder: '输入的文本内容', default: '' }
                        ]
                    },
                    { 
                        type: 'clear', 
                        label: '清理',
                        tksCommand: '清理',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML元素', default: '' }
                        ]
                    },
                    { 
                        type: 'hide_keyboard', 
                        label: '隐藏键盘',
                        tksCommand: '隐藏键盘',
                        params: []
                    }
                ]
            },
            control: {
                color: '#ce9178',
                icon: '⏱',
                commands: [
                    { 
                        type: 'wait', 
                        label: '等待',
                        tksCommand: '等待',
                        params: [
                            { name: 'duration', type: 'number', placeholder: '等待时长/ms', default: '1000' }
                        ]
                    },
                    { 
                        type: 'back', 
                        label: '返回',
                        tksCommand: '返回',
                        params: []
                    }
                ]
            },
            assertion: {
                color: '#f48771',
                icon: '<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M9.5,3A6.5,6.5 0 0,1 16,9.5C16,11.11 15.41,12.59 14.44,13.73L14.71,14H15.5L20.5,19L19,20.5L14,15.5V14.71L13.73,14.44C12.59,15.41 11.11,16 9.5,16A6.5,6.5 0 0,1 3,9.5A6.5,6.5 0 0,1 9.5,3M9.5,5C7,5 5,7 5,9.5C5,12 7,14 9.5,14C12,14 14,12 14,9.5C14,7 12,5 9.5,5Z"/></svg>',
                commands: [
                    { 
                        type: 'assert', 
                        label: '断言',
                        tksCommand: '断言',
                        params: [
                            { name: 'target', type: 'element', placeholder: 'XML/图片元素', default: '' },
                            { name: 'condition', type: 'select', options: ['存在', '不存在', '可见', '不可见'], default: '存在' }
                        ]
                    }
                ]
            },
            text: {
                color: '#9cdcfe',
                icon: '📖',
                commands: [
                    { 
                        type: 'read', 
                        label: '读取',
                        tksCommand: '读取',
                        params: [
                            { name: 'target', type: 'element', placeholder: '坐标/XML元素', default: '' },
                            { name: 'leftRight', type: 'number', placeholder: '左右扩展', default: '' },
                            { name: 'upDown', type: 'number', placeholder: '上下扩展', default: '' }
                        ]
                    }
                ]
            }
        };
        
        this.init();
    }
    
    init() {
        console.log('EditorTab 初始化中...');
        this.createEditor();
        this.setupEventListeners();
        // 默认渲染为块模式
        this.render();
        console.log('EditorTab 初始化完成，当前模式:', this.currentMode);
    }
    
    createEditor() {
        const containerId = `${this.uniqueId}-container`;
        this.container.innerHTML = `
            <div class="unified-editor">
                <!-- 统一的内容容器 -->
                <div class="editor-content-container" id="${containerId}">
                    <!-- 内容将根据模式动态渲染 -->
                </div>
            </div>
        `;
        
        this.editorContainer = this.container.querySelector(`#${containerId}`);
    }
    
    setupEventListeners() {
        // 不再在这里监听全局快捷键，由 EditorManager 统一处理
        // 只处理编辑器内部的事件
    }
    
    toggleMode() {
        // 这个方法保留用于向后兼容，但优先使用全局切换
        if (this.currentMode === 'text') {
            this.switchToBlockMode();
        } else {
            this.switchToTextMode();
        }
    }
    
    switchToTextMode() {
        console.log('切换到文本模式');
        
        // 保存当前高亮状态
        const savedHighlightLine = this.currentHighlightedLine;
        const wasTestRunning = this.isTestRunning;
        
        this.currentMode = 'text';
        this.render();
        
        // 恢复高亮状态
        if (savedHighlightLine !== null && wasTestRunning) {
            console.log('恢复文本模式高亮:', savedHighlightLine);
            // 延迟一点确保DOM已完全渲染
            setTimeout(() => {
                this.highlightExecutingLine(savedHighlightLine);
            }, 50);
        }
    }
    
    switchToBlockMode() {
        console.log('切换到块编程模式');
        
        // 保存当前高亮状态
        const savedHighlightLine = this.currentHighlightedLine;
        const wasTestRunning = this.isTestRunning;
        
        this.currentMode = 'block';
        this.render();
        
        // 恢复高亮状态
        if (savedHighlightLine !== null && wasTestRunning) {
            console.log('恢复块模式高亮:', savedHighlightLine);
            // 延迟一点确保DOM已完全渲染
            setTimeout(() => {
                this.highlightExecutingLine(savedHighlightLine);
            }, 50);
        }
    }
    
    render() {
        if (this.currentMode === 'text') {
            this.renderTextMode();
        } else {
            this.renderBlockMode();
        }
    }
    
    renderTextMode() {
        console.log('渲染文本模式...');
        const tksCode = this.script.toTKSCode();
        
        const lineNumbersId = `${this.uniqueId}-lines`;
        const textContentId = `${this.uniqueId}-text`;
        
        this.editorContainer.innerHTML = `
            <div class="text-editor-view">
                <div class="text-editor-wrapper">
                    <div class="line-numbers" id="${lineNumbersId}"></div>
                    <div class="text-content" id="${textContentId}" contenteditable="true">${this.highlightTKSSyntax(tksCode)}</div>
                </div>
            </div>
        `;
        
        // 在编辑器范围内创建状态指示器
        const editorContainer = this.container;
        if (editorContainer) {
            // 移除旧的内联状态指示器（如果存在）
            const oldIndicators = this.editorContainer.querySelectorAll('.editor-status-indicator');
            oldIndicators.forEach(indicator => indicator.remove());
            
            // 更新状态指示器
            this.updateStatusIndicator();
        } else {
            console.error('找不到编辑器容器');
        }
        
        this.textContentEl = this.editorContainer.querySelector('.text-content');
        this.lineNumbersEl = this.editorContainer.querySelector('.line-numbers');
        
        console.log('文本模式DOM元素:', {
            textContentEl: this.textContentEl,
            lineNumbersEl: this.lineNumbersEl,
            statusIndicatorEl: this.statusIndicatorEl
        });
        
        this.setupTextModeListeners();
        this.updateLineNumbers();
        
        // 更新状态指示器
        this.updateStatusIndicator();
    }
    
    renderBlockMode() {
        const blocksContainerId = `${this.uniqueId}-blocks`;
        
        this.editorContainer.innerHTML = `
            <div class="block-editor-view">
                <div class="blocks-workspace">
                    <div class="blocks-container" id="${blocksContainerId}"></div>
                </div>
            </div>
        `;
        
        // 在块模式下，更新状态指示器
        this.updateStatusIndicator();
        
        this.blocksContainer = this.editorContainer.querySelector('.blocks-container');
        
        console.log('块编辑器DOM元素:', {
            editorContainer: this.editorContainer,
            blocksContainer: this.blocksContainer
        });
        
        if (this.blocksContainer) {
            this.renderBlocks();
            this.setupBlockModeListeners();
        } else {
            console.error('无法找到块编辑器DOM元素');
        }
    }
    
    
    renderBlocks() {
        const commands = this.script.getCommands();
        let blocksHtml = '';
        
        // 为每个命令块生成HTML，包括块间的插入按钮
        commands.forEach((command, index) => {
            const definition = this.findCommandDefinition(command.type);
            const category = this.findCommandCategory(command.type);
            
            if (!definition || !category) return;
            
            // 创建带参数孔的指令块 - 混合文本和输入框
            let commandContent = `<span class="block-icon">${category.icon}</span><span class="command-label">${definition.label}</span>`;
            
            // 为每个参数创建输入框，并整合到命令中
            if (definition.params.length > 0) {
                definition.params.forEach((param, paramIndex) => {
                    const value = command.params[param.name] || param.default || '';
                    const paramId = `param-${index}-${param.name}`;
                    
                    if (param.type === 'select') {
                        const optionsHtml = param.options.map(opt => 
                            `<option value="${opt}" ${value === opt ? 'selected' : ''}>${opt}</option>`
                        ).join('');
                        commandContent += `
                            <select class="param-hole" 
                                    id="${paramId}"
                                    data-param="${param.name}"
                                    data-command-index="${index}"
                                    title="${param.placeholder}">
                                ${optionsHtml}
                            </select>
                        `;
                    } else {
                        // 检查参数类型是否为element，以支持可视化渲染
                        if (param.type === 'element') {
                            if (value && (value.match(/^@\{(.+)\}$/) || value.match(/^\{(.+)\}$/))) {
                                // 检查值是否为图片引用格式 @{name} 或 XML元素引用格式 {name}
                                const imageMatch = value.match(/^@\{(.+)\}$/);
                                const xmlMatch = value.match(/^\{(.+)\}$/);
                                
                                // 创建一个容器用于显示可视化元素
                                commandContent += `
                                    <div class="param-hole-container" 
                                         data-param="${param.name}"
                                         data-command-index="${index}"
                                         data-type="element">
                                        <input class="param-hole hidden-input" 
                                               id="${paramId}"
                                               type="hidden"
                                               data-param="${param.name}"
                                               data-command-index="${index}"
                                               value="${value}">
                                        <div class="param-visual-element" 
                                             id="visual-${paramId}"
                                             data-param="${param.name}"
                                             data-command-index="${index}">
                                            <!-- 可视化内容将在渲染后动态添加 -->
                                        </div>
                                    </div>
                                `;
                            } else {
                                // element 类型的普通文本输入框（无论是否有值）
                                commandContent += `
                                    <input class="param-hole" 
                                           id="${paramId}"
                                           type="text"
                                           data-param="${param.name}"
                                           data-command-index="${index}"
                                           data-param-type="element"
                                           placeholder="${param.placeholder}"
                                           title="${param.placeholder}"
                                           value="${value}">
                                `;
                            }
                        } else {
                            // 非locator类型的普通输入框
                            commandContent += `
                                <input class="param-hole" 
                                       id="${paramId}"
                                       type="${param.type === 'number' ? 'number' : 'text'}"
                                       data-param="${param.name}"
                                       data-command-index="${index}"
                                       placeholder="${param.placeholder}"
                                       title="${param.placeholder}"
                                       value="${value}">
                            `;
                        }
                    }
                });
            }
            
            // 单行命令块 - 保持原有颜色背景
            const blockHtml = `
                <div class="workspace-block command-block" 
                     data-index="${index}"
                     data-type="${command.type}"
                     draggable="true"
                     style="background: linear-gradient(135deg, ${category.color}ee, ${category.color}cc);">
                    <div class="command-content">
                        ${commandContent}
                    </div>
                    <button class="block-delete" data-index="${index}" title="删除">×</button>
                </div>
            `;
            
            blocksHtml += blockHtml;
        });
        
        // 最后添加一个插入按钮
        const finalInsertButton = `
            <div class="block-insert-area final" data-insert-index="${commands.length}">
                <button class="block-insert-btn" title="添加命令块">
                    <svg width="16" height="16" viewBox="0 0 16 16">
                        <path fill="currentColor" d="M8 2v12m-6-6h12"/>
                    </svg>
                </button>
            </div>
        `;
        
        if (commands.length === 0) {
            // 空状态
            this.blocksContainer.innerHTML = `
                <div class="empty-state">
                    <svg width="48" height="48" viewBox="0 0 48 48" opacity="0.3">
                        <path fill="currentColor" d="M38 8H10c-2.21 0-4 1.79-4 4v24c0 2.21 1.79 4 4 4h28c2.21 0 4-1.79 4-4V12c0-2.21-1.79-4-4-4z"/>
                    </svg>
                    <p>在左侧Explorer中点击脚本后开始编辑</p>
                </div>
                ${finalInsertButton}
            `;
        } else {
            this.blocksContainer.innerHTML = blocksHtml + finalInsertButton;
        }
        
        // 渲染完成后，处理可视化元素
        this.renderVisualElements();
        
        // 为locator类型的输入框添加拖放支持
        this.setupLocatorInputDragDrop();
    }
    
    // 渲染可视化元素
    renderVisualElements() {
        const visualElements = this.blocksContainer.querySelectorAll('.param-visual-element');
        
        visualElements.forEach(element => {
            const commandIndex = parseInt(element.dataset.commandIndex);
            const paramName = element.dataset.param;
            const command = this.script.getCommands()[commandIndex];
            
            if (command && command.params[paramName]) {
                const value = command.params[paramName];
                
                const imageMatch = value.match(/^@\{(.+)\}$/);
                const xmlMatch = value.match(/^\{(.+)\}$/);
                
                if (imageMatch) {
                    // 渲染图片元素
                    const imageName = imageMatch[1];
                    // 获取项目路径
                    const { path: PathModule } = window.AppGlobals;
                    const projectPath = window.AppGlobals.currentProject;
                    const imagePath = projectPath ? PathModule.join(projectPath, 'locator/img', `${imageName}.png`) : '';
                    
                    element.innerHTML = `
                        <div class="visual-image-card">
                            <img src="${imagePath}" alt="${imageName}" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                            <div class="image-fallback" style="display:none;">
                                <svg width="24" height="24" viewBox="0 0 24 24">
                                    <path fill="currentColor" d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
                                </svg>
                            </div>
                            <span class="visual-name">${imageName}</span>
                            <button class="visual-remove" data-command-index="${commandIndex}" data-param="${paramName}">×</button>
                        </div>
                    `;
                } else if (xmlMatch) {
                    // 渲染XML元素卡片
                    const elementName = xmlMatch[1];
                    element.innerHTML = `
                        <div class="visual-xml-card">
                            <svg width="20" height="20" viewBox="0 0 24 24">
                                <path fill="#4a90e2" d="M8 3a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2H3v2h1a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h2v-2H8v-4a2 2 0 0 0-2-2 2 2 0 0 0 2-2V5h2V3m6 0a2 2 0 0 1 2 2v4a2 2 0 0 0 2 2h1v2h-1a2 2 0 0 0-2 2v4a2 2 0 0 1-2 2h-2v-2h2v-4a2 2 0 0 1 2-2 2 2 0 0 1-2-2V5h-2V3"/>
                            </svg>
                            <span class="visual-name">${elementName}</span>
                            <button class="visual-remove" data-command-index="${commandIndex}" data-param="${paramName}">×</button>
                        </div>
                    `;
                }
            }
        });
        
        // 为移除按钮添加事件监听
        this.blocksContainer.querySelectorAll('.visual-remove').forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const commandIndex = parseInt(btn.dataset.commandIndex);
                const paramName = btn.dataset.param;
                
                // 清空参数值
                const command = this.script.getCommands()[commandIndex];
                if (command) {
                    command.params[paramName] = '';
                    this.renderBlocks();
                    this.setupBlockModeListeners();
                    this.triggerChange();
                }
            });
        });
    }
    
    // 为locator类型的输入框添加拖放支持
    setupLocatorInputDragDrop() {
        console.log('设置拖拽监听器...');
        
        // 移除之前的拖拽监听器（如果存在）
        if (this.dragOverHandler) {
            this.blocksContainer.removeEventListener('dragover', this.dragOverHandler);
        }
        if (this.dragLeaveHandler) {
            this.blocksContainer.removeEventListener('dragleave', this.dragLeaveHandler);
        }
        if (this.dropHandler) {
            this.blocksContainer.removeEventListener('drop', this.dropHandler);
        }
        
        // 使用事件委托，在块容器上监听拖拽事件
        this.dragOverHandler = (e) => {
            // 查找拖拽目标
            const dropTarget = this.findDropTarget(e.target);
            if (!dropTarget) return;
            
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
            
            // 清除之前的高亮
            this.blocksContainer.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            // 添加当前目标的高亮
            dropTarget.classList.add('drag-over');
            console.log('拖拽悬停在:', dropTarget, '数据:', dropTarget.dataset);
        };
        
        this.dragLeaveHandler = (e) => {
            const dropTarget = this.findDropTarget(e.target);
            if (!dropTarget) return;
            
            // 检查鼠标是否真的离开了目标区域
            const rect = dropTarget.getBoundingClientRect();
            const isInside = e.clientX >= rect.left && e.clientX <= rect.right && 
                           e.clientY >= rect.top && e.clientY <= rect.bottom;
            
            if (!isInside) {
                dropTarget.classList.remove('drag-over');
            }
        };
        
        this.dropHandler = (e) => {
            const dropTarget = this.findDropTarget(e.target);
            if (!dropTarget) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            console.log('拖拽放置在:', dropTarget);
            
            // 清除高亮
            dropTarget.classList.remove('drag-over');
            
            // 获取参数信息
            const commandIndex = parseInt(dropTarget.dataset.commandIndex);
            const paramName = dropTarget.dataset.param;
            
            if (isNaN(commandIndex) || !paramName) {
                console.warn('无法获取命令索引或参数名:', { commandIndex, paramName, dataset: dropTarget.dataset });
                return;
            }
            
            // 获取拖拽数据
            const locatorDataStr = e.dataTransfer.getData('application/json');
            const textData = e.dataTransfer.getData('text/plain');
            
            window.rLog(`🔄 块编辑器接收拖拽数据: textData="${textData}", locatorDataStr="${locatorDataStr}"`);
            
            if (textData && this.buffer) {
                // 通过TKE缓冲区更新块编辑器内容
                window.rLog(`🔧 块编辑器拖拽更新: 命令${commandIndex}, 参数${paramName}, 值${textData}`);
                
                // 构造更新后的命令行（临时实现，理想情况下TKE应提供接口）
                const updatedLine = this.constructUpdatedCommandLine(commandIndex, paramName, textData);
                
                if (updatedLine) {
                    // 通过缓冲区更新内容
                    await this.buffer.updateFromBlocks({
                        commandIndex: commandIndex,
                        updatedLine: updatedLine
                    });
                    
                    window.rLog('✅ 块编辑器参数更新完成');
                } else {
                    window.rError('❌ 构造更新命令行失败');
                }
            } else {
                window.rError(`❌ 块编辑器未获取到拖拽数据或缓冲区未初始化，textData: ${textData}, buffer: ${!!this.buffer}`);
            }
        };
        
        // 添加事件监听器
        this.blocksContainer.addEventListener('dragover', this.dragOverHandler);
        this.blocksContainer.addEventListener('dragleave', this.dragLeaveHandler);
        this.blocksContainer.addEventListener('drop', this.dropHandler);
        
        // 统计当前可拖拽目标数量
        const dropTargets = this.getAllDropTargets();
        console.log(`已设置拖拽监听器，找到 ${dropTargets.length} 个可拖拽目标:`, dropTargets);
    }
    
    // 构造更新后的命令行（临时实现）
    constructUpdatedCommandLine(commandIndex, paramName, newValue) {
        if (!this.buffer) return null;
        
        const content = this.buffer.getRawContent();
        const lines = content.split('\n');
        
        let currentCommandIndex = -1;
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i].trim();
            if (this.isCommandLine(line)) {
                currentCommandIndex++;
                if (currentCommandIndex === commandIndex) {
                    // 找到目标命令行，构造更新后的行
                    return this.updateCommandLineParameter(line, paramName, newValue);
                }
            }
        }
        
        return null;
    }
    
    // 更新命令行中的参数（临时实现，应该由TKE提供）
    updateCommandLineParameter(commandLine, paramName, newValue) {
        // 根据TKS语法规范更新命令行
        // 例如: 点击 [{200,400}] -> 点击 [{设置}]
        
        if (paramName === 'target') {
            // 替换目标参数
            if (commandLine.includes('[') && commandLine.includes(']')) {
                // 替换方括号中的内容
                return commandLine.replace(/\[([^\]]*)\]/, `[${newValue}]`);
            } else {
                // 添加参数
                return `${commandLine} [${newValue}]`;
            }
        }
        
        // 其他参数类型的处理...
        return commandLine;
    }
    
    // 判断是否是命令行（与TKE缓冲区中的实现保持一致）
    isCommandLine(line) {
        if (!line || line.startsWith('#') || line.startsWith('用例:') || 
            line.startsWith('脚本名:') || line === '详情:' || line === '步骤:' ||
            line.includes('appPackage:') || line.includes('appActivity:')) {
            return false;
        }
        return true;
    }
    
    // 查找有效的拖拽目标
    findDropTarget(element) {
        let current = element;
        while (current && current !== this.blocksContainer) {
            // 检查是否是element类型的输入框或容器
            if ((current.classList.contains('param-hole') && current.dataset.paramType === 'element') ||
                (current.classList.contains('param-hole-container') && current.dataset.type === 'element') ||
                current.matches('input[data-param-type="element"]')) {
                
                console.log('找到拖拽目标:', current, {
                    classList: current.classList.toString(),
                    dataset: current.dataset,
                    tagName: current.tagName
                });
                return current;
            }
            current = current.parentElement;
        }
        console.log('未找到拖拽目标，检查的元素:', element);
        return null;
    }
    
    // 获取所有可拖拽目标（用于调试）
    getAllDropTargets() {
        return this.blocksContainer.querySelectorAll(
            'input[data-param-type="element"], .param-hole[data-param-type="element"], .param-hole-container[data-type="element"]'
        );
    }
    
    setupTextModeListeners() {
        // 获取文本内容元素
        this.textContentEl = this.editorContainer.querySelector('.text-content');
        if (!this.textContentEl) {
            console.warn('textContent元素未找到');
            return;
        }
        
        this.textContentEl.addEventListener('input', () => {
            if (this.isTestRunning) return;
            
            // 从文本更新脚本模型
            const tksCode = this.textContentEl.textContent || '';
            this.script.fromTKSCode(tksCode);
            this.updateLineNumbers();
            this.triggerChange();
        });
        
        this.textContentEl.addEventListener('keydown', (e) => {
            if (this.isTestRunning) {
                e.preventDefault();
                return;
            }
            
            // 只处理编辑器特定的快捷键
            if (e.key === 'Tab') {
                e.preventDefault();
                document.execCommand('insertText', false, '  ');
            } else if (e.key === 'Enter') {
                e.preventDefault();
                document.execCommand('insertText', false, '\n');
            }
            // 其他按键正常处理，不阻止
        });
        
        // 添加拖放支持
        this.textContentEl.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        });
        
        this.textContentEl.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // 获取拖拽的文本数据
            const text = e.dataTransfer.getData('text/plain');
            
            if (text) {
                // 根据鼠标位置创建插入点
                const range = document.caretRangeFromPoint(e.clientX, e.clientY);
                if (range) {
                    // 确保插入点在文本编辑器内
                    if (this.textContentEl.contains(range.startContainer)) {
                        // 清除当前选区并设置新位置
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        // 插入文本
                        range.deleteContents();
                        const textNode = document.createTextNode(text);
                        range.insertNode(textNode);
                        
                        // 移动光标到插入文本的末尾
                        range.setStartAfter(textNode);
                        range.setEndAfter(textNode);
                        range.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        // 更新脚本模型
                        const tksCode = this.textContentEl.textContent || '';
                        this.script.fromTKSCode(tksCode);
                        this.updateLineNumbers();
                        this.triggerChange();
                    }
                } else {
                    // 降级方案：使用当前光标位置
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        range.deleteContents();
                        const textNode = document.createTextNode(text);
                        range.insertNode(textNode);
                        
                        // 移动光标到插入文本的末尾
                        range.setStartAfter(textNode);
                        range.setEndAfter(textNode);
                        selection.removeAllRanges();
                        selection.addRange(range);
                        
                        // 更新脚本模型
                        const tksCode = this.textContentEl.textContent || '';
                        this.script.fromTKSCode(tksCode);
                        this.updateLineNumbers();
                        this.triggerChange();
                    }
                }
            }
        });
    }
    
    setupBlockModeListeners() {
        // 不再使用全局标记，因为每次重新渲染后都需要重新绑定事件
        
        // 点击事件处理器
        this.container.addEventListener('click', (e) => {
            if (e.target.classList.contains('block-delete')) {
                e.preventDefault();
                e.stopPropagation();
                const index = parseInt(e.target.dataset.index);
                console.log(`删除命令块，索引: ${index}, 当前命令数量: ${this.script.getCommands().length}`);
                
                // 验证索引有效性
                if (index >= 0 && index < this.script.getCommands().length) {
                    this.removeCommand(index);
                } else {
                    console.warn(`无效的删除索引: ${index}`);
                }
            } else if (e.target.classList.contains('block-insert-btn') || e.target.closest('.block-insert-btn')) {
                const insertArea = e.target.closest('.block-insert-area');
                const insertIndex = parseInt(insertArea.dataset.insertIndex);
                this.showCommandMenu(insertArea, insertIndex);
            }
        });
        
        // 拖拽事件
        this.container.addEventListener('dragstart', (e) => {
            if (this.isTestRunning) {
                e.preventDefault();
                return;
            }
            
            const block = e.target.closest('.workspace-block.command-block');
            if (block) {
                block.classList.add('dragging');
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    type: 'reorder',
                    fromIndex: parseInt(block.dataset.index)
                }));
                e.dataTransfer.effectAllowed = 'move';
            }
        });
        
        this.container.addEventListener('dragend', (e) => {
            const block = e.target.closest('.workspace-block.command-block');
            if (block) {
                block.classList.remove('dragging');
            }
            // 清除所有拖拽高亮
            this.blocksContainer.querySelectorAll('.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
        });
        
        this.container.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            // 找到最近的块并高亮
            const block = e.target.closest('.workspace-block.command-block');
            if (block && !block.classList.contains('dragging')) {
                // 清除之前的高亮
                this.blocksContainer.querySelectorAll('.drag-over').forEach(el => {
                    el.classList.remove('drag-over');
                });
                
                // 添加新的高亮
                const rect = block.getBoundingClientRect();
                const midY = rect.top + rect.height / 2;
                if (e.clientY < midY) {
                    block.classList.add('drag-over');
                } else {
                    // 高亮下一个块的上边缘
                    const nextBlock = block.nextElementSibling;
                    if (nextBlock && nextBlock.classList.contains('command-block')) {
                        nextBlock.classList.add('drag-over');
                    }
                }
            }
        });
        
        this.container.addEventListener('drop', (e) => {
            e.preventDefault();
            if (this.isTestRunning) return;
            
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            if (data.type === 'reorder') {
                const targetBlock = e.target.closest('.workspace-block.command-block');
                if (targetBlock && !targetBlock.classList.contains('dragging')) {
                    const toIndex = parseInt(targetBlock.dataset.index);
                    const rect = targetBlock.getBoundingClientRect();
                    const midY = rect.top + rect.height / 2;
                    
                    // 确定插入位置
                    let insertIndex = toIndex;
                    if (e.clientY >= midY) {
                        insertIndex = toIndex + 1;
                    }
                    
                    this.reorderCommand(data.fromIndex, insertIndex);
                }
            }
        });
        
        // 右键菜单
        this.container.addEventListener('contextmenu', (e) => {
            console.log('右键菜单事件触发');
            const block = e.target.closest('.workspace-block.command-block');
            console.log('找到的块元素:', !!block);
            if (block) {
                console.log('块索引:', block.dataset.index);
                console.log('测试运行状态:', this.isTestRunning);
                e.preventDefault();
                this.showContextMenu(e.clientX, e.clientY, parseInt(block.dataset.index));
            }
        });
        
        // 参数输入
        this.container.addEventListener('input', (e) => {
            if (this.isTestRunning) return;
            
            if (e.target.classList.contains('param-hole')) {
                const index = parseInt(e.target.dataset.commandIndex);
                const param = e.target.dataset.param;
                this.updateCommandParam(index, param, e.target.value);
            }
        });
        
        this.container.addEventListener('change', (e) => {
            if (e.target.classList.contains('param-hole') && e.target.tagName === 'SELECT') {
                const index = parseInt(e.target.dataset.commandIndex);
                const param = e.target.dataset.param;
                this.updateCommandParam(index, param, e.target.value);
            }
        });
        
        // 点击其他地方关闭菜单
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.command-menu') && !e.target.closest('.block-insert-btn') && !e.target.closest('.temp-insert')) {
                this.hideCommandMenu();
            }
            if (!e.target.closest('.context-menu')) {
                this.hideContextMenu();
            }
        });
        
        // 重新设置拖拽监听器（确保删除元素后拖拽功能仍然可用）
        this.setupLocatorInputDragDrop();
    }
    
    // 显示命令选择菜单
    showCommandMenu(insertArea, insertIndex) {
        console.log(`showCommandMenu 被调用，插入位置: ${insertIndex}, 插入区域存在: ${!!insertArea}`);
        
        if (this.isTestRunning) {
            console.log('测试运行中，无法显示命令菜单');
            return;
        }
        
        if (!insertArea) {
            console.error('插入区域不存在，无法显示命令菜单');
            return;
        }
        
        // 隐藏现有菜单
        this.hideCommandMenu();
        
        // 创建菜单HTML
        const menuItems = [];
        Object.entries(this.blockDefinitions).forEach(([categoryKey, category]) => {
            category.commands.forEach(cmd => {
                menuItems.push(`
                    <div class="command-menu-item" data-type="${cmd.type}" data-insert-index="${insertIndex}">
                        <span class="menu-item-icon">${category.icon}</span>
                        <span class="menu-item-label">${cmd.label}</span>
                    </div>
                `);
            });
        });
        
        console.log(`创建了 ${menuItems.length} 个菜单项`);
        
        const menuHtml = `
            <div class="command-menu" id="commandMenu">
                ${menuItems.join('')}
            </div>
        `;
        
        // 插入菜单到插入区域
        console.log('将菜单HTML插入到插入区域');
        insertArea.insertAdjacentHTML('beforeend', menuHtml);
        this.currentMenu = insertArea.querySelector('.command-menu');
        
        if (this.currentMenu) {
            console.log('菜单元素创建成功，菜单项数量:', this.currentMenu.querySelectorAll('.command-menu-item').length);
            // 确保菜单可见
            this.currentMenu.style.display = 'block';
            this.currentMenu.style.visibility = 'visible';
            console.log('菜单样式:', window.getComputedStyle(this.currentMenu).display, window.getComputedStyle(this.currentMenu).visibility);
        } else {
            console.error('菜单元素创建失败');
        }
        
        // 绑定菜单项点击事件
        this.currentMenu.addEventListener('click', (e) => {
            const menuItem = e.target.closest('.command-menu-item');
            if (menuItem) {
                const commandType = menuItem.dataset.type;
                const index = parseInt(menuItem.dataset.insertIndex);
                this.insertCommand(commandType, index);
                this.hideCommandMenu();
            }
        });
    }
    
    // 隐藏命令选择菜单
    hideCommandMenu() {
        if (this.currentMenu) {
            this.currentMenu.remove();
            this.currentMenu = null;
        }
    }

    // 脚本操作方法
    addCommand(type) {
        const definition = this.findCommandDefinition(type);
        if (!definition) return;
        
        const command = {
            type: type,
            params: {}
        };
        
        // 初始化参数
        definition.params.forEach(param => {
            command.params[param.name] = param.default || '';
        });
        
        this.script.addCommand(command);
        this.renderBlocks();
        this.triggerChange();
    }
    
    // 插入命令（在指定位置）
    insertCommand(type, index) {
        const definition = this.findCommandDefinition(type);
        if (!definition) return;
        
        const command = {
            type: type,
            params: {}
        };
        
        // 初始化参数
        definition.params.forEach(param => {
            command.params[param.name] = param.default || '';
        });
        
        this.script.insertCommand(command, index);
        this.renderBlocks();
        this.triggerChange();
    }
    
    // 重新排序命令
    reorderCommand(fromIndex, toIndex) {
        if (fromIndex === toIndex) return;
        
        // 调整索引以适应移动后的位置
        let adjustedToIndex = toIndex;
        if (fromIndex < toIndex) {
            adjustedToIndex = toIndex - 1;
        }
        
        this.script.reorderCommand(fromIndex, adjustedToIndex);
        this.renderBlocks();
        this.triggerChange();
        
        console.log(`已移动命令：从位置 ${fromIndex} 到位置 ${adjustedToIndex}`);
    }
    
    // 显示右键菜单
    showContextMenu(x, y, blockIndex) {
        console.log(`显示右键菜单，位置: (${x}, ${y}), 块索引: ${blockIndex}`);
        
        // 移除现有菜单
        this.hideContextMenu();
        
        const menuHtml = `
            <div class="context-menu" id="blockContextMenu" style="left: ${x}px; top: ${y}px;">
                <div class="context-menu-item" data-action="insert-below" data-index="${blockIndex}">
                    <span class="context-menu-item-icon">+</span>
                    在下方插入命令
                </div>
            </div>
        `;
        
        // 移除旧的菜单
        if (this.currentContextMenu) {
            this.currentContextMenu.remove();
        }
        
        const menuId = `${this.uniqueId}-context-menu`;
        const updatedMenuHtml = menuHtml.replace('id="blockContextMenu"', `id="${menuId}"`);
        document.body.insertAdjacentHTML('beforeend', updatedMenuHtml);
        this.currentContextMenu = document.querySelector(`#${menuId}`);
        
        console.log('右键菜单DOM元素已创建:', !!this.currentContextMenu);
        if (this.currentContextMenu) {
            console.log('菜单位置:', this.currentContextMenu.style.left, this.currentContextMenu.style.top);
            console.log('菜单尺寸:', this.currentContextMenu.offsetWidth, 'x', this.currentContextMenu.offsetHeight);
        }
        
        // 绑定菜单项点击事件
        this.currentContextMenu.addEventListener('click', (e) => {
            console.log('右键菜单项被点击');
            e.preventDefault();
            e.stopPropagation(); // 防止事件冒泡到document，导致菜单立即隐藏
            
            const menuItem = e.target.closest('.context-menu-item');
            if (menuItem) {
                const action = menuItem.dataset.action;
                const index = parseInt(menuItem.dataset.index);
                console.log(`菜单项动作: ${action}, 索引: ${index}`);
                
                if (action === 'insert-below') {
                    // 显示命令选择菜单在指定块下方
                    console.log(`尝试在块 ${index} 下方插入命令（插入位置: ${index + 1}）`);
                    this.hideContextMenu(); // 先隐藏右键菜单
                    
                    // 使用 setTimeout 延迟执行，避免立即被全局点击事件隐藏
                    setTimeout(() => {
                        this.showInsertMenuAtBlock(index + 1);
                    }, 50);
                }
            }
        });
        
        // 点击其他地方关闭菜单
        setTimeout(() => {
            document.addEventListener('click', this.hideContextMenu.bind(this), { once: true });
        }, 0);
    }
    
    // 隐藏右键菜单
    hideContextMenu() {
        if (this.currentContextMenu) {
            this.currentContextMenu.remove();
            this.currentContextMenu = null;
        }
    }
    
    // 在指定块下方显示插入菜单
    showInsertMenuAtBlock(insertIndex) {
        console.log(`showInsertMenuAtBlock 被调用，插入位置: ${insertIndex}`);
        
        const blocks = this.blocksContainer.querySelectorAll('.workspace-block.command-block');
        console.log(`找到 ${blocks.length} 个命令块`);
        
        let targetBlock = null;
        
        if (insertIndex > 0 && insertIndex - 1 < blocks.length) {
            targetBlock = blocks[insertIndex - 1];
            console.log(`目标块索引: ${insertIndex - 1}, 找到目标块:`, !!targetBlock);
        }
        
        // 创建临时插入区域
        const tempInsertArea = document.createElement('div');
        tempInsertArea.className = 'block-insert-area temp-insert';
        tempInsertArea.dataset.insertIndex = insertIndex;
        tempInsertArea.innerHTML = `
            <button class="block-insert-btn temp" title="选择要插入的命令">
                <svg width="16" height="16" viewBox="0 0 16 16">
                    <path fill="currentColor" d="M8 2v12m-6-6h12"/>
                </svg>
            </button>
        `;
        
        console.log('临时插入区域已创建');
        
        // 插入临时区域
        if (targetBlock) {
            targetBlock.insertAdjacentElement('afterend', tempInsertArea);
            console.log('临时区域已插入到目标块后面');
        } else {
            this.blocksContainer.insertBefore(tempInsertArea, this.blocksContainer.firstChild);
            console.log('临时区域已插入到容器开头');
        }
        
        // 验证临时区域是否成功插入到DOM
        console.log('临时区域是否在DOM中:', document.contains(tempInsertArea));
        console.log('临时区域的父元素:', tempInsertArea.parentElement);
        console.log('临时区域位置:', tempInsertArea.getBoundingClientRect());
        
        // 立即显示菜单
        console.log('准备显示命令菜单');
        this.showCommandMenu(tempInsertArea, insertIndex);
        
        // 菜单关闭时移除临时区域
        const originalHideMenu = this.hideCommandMenu.bind(this);
        this.hideCommandMenu = () => {
            originalHideMenu();
            
            // 移除临时插入区域
            if (tempInsertArea && tempInsertArea.parentNode) {
                console.log('移除临时插入区域');
                tempInsertArea.remove();
            }
            
            // 恢复原来的 hideCommandMenu 方法
            this.hideCommandMenu = originalHideMenu;
        };
    }
    
    removeCommand(index) {
        console.log(`开始删除命令，索引: ${index}`);
        const commandsBefore = this.script.getCommands().length;
        console.log(`删除前命令数量: ${commandsBefore}`);
        console.log('删除前的命令列表:', this.script.getCommands().map((cmd, i) => `${i}: ${cmd.type}`));
        
        this.script.removeCommand(index);
        
        const commandsAfter = this.script.getCommands().length;
        console.log(`删除后命令数量: ${commandsAfter}`);
        console.log('删除后的命令列表:', this.script.getCommands().map((cmd, i) => `${i}: ${cmd.type}`));
        
        this.renderBlocks();
        this.triggerChange();
    }
    
    
    updateCommandParam(index, param, value) {
        this.script.updateCommandParam(index, param, value);
        this.triggerChange();
    }
    
    // 工具方法
    findCommandDefinition(type) {
        for (const category of Object.values(this.blockDefinitions)) {
            const cmd = category.commands.find(c => c.type === type);
            if (cmd) return cmd;
        }
        return null;
    }
    
    findCommandCategory(type) {
        for (const [key, category] of Object.entries(this.blockDefinitions)) {
            if (category.commands.find(c => c.type === type)) {
                return category;
            }
        }
        return null;
    }
    
    getCategoryName(key) {
        const names = {
            application: '应用控制',
            action: '动作操作', 
            input: '输入操作',
            control: '时间控制',
            navigation: '导航操作',
            assertion: '断言验证'
        };
        return names[key] || key;
    }
    
    highlightTKSSyntax(text) {
        // 新TKS语法高亮
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            // 高亮命令名
            .replace(/(启动|关闭|点击|按压|滑动|拖动|定向拖动|输入|清理|隐藏键盘|返回|等待|断言|读取)/g, '<span class="syntax-action">$1</span>')
            // 高亮图片元素 @{图片名称}
            .replace(/@\{([^}]+)\}/g, '@{<span class="syntax-string">$1</span>}')
            // 高亮坐标 {x,y}
            .replace(/\{(\d+\s*,\s*\d+)\}/g, '{<span class="syntax-coordinate">$1</span>}')
            // 高亮XML元素 {元素名称}
            .replace(/\{([^}]+)\}/g, '{<span class="syntax-xml-element">$1</span>}')
            // 高亮参数列表
            .replace(/\[([^\]]+)\]/g, '[<span class="syntax-param">$1</span>]');
    }
    
    updateLineNumbers() {
        if (!this.lineNumbersEl || !this.textContentEl) return;
        
        const text = this.textContentEl.textContent || '';
        const lines = text.split('\n');
        const lineNumbersHtml = lines.map((_, index) => 
            `<div class="line-number">${index + 1}</div>`
        ).join('');
        this.lineNumbersEl.innerHTML = lineNumbersHtml;
    }
    
    triggerChange() {
        window.rLog(`📤 triggerChange 被调用，模式: ${this.currentMode}`);
        
        this.listeners.forEach(listener => {
            if (listener.type === 'change') {
                const content = this.buffer ? this.buffer.getRawContent() : '';
                listener.callback(content);
            }
        });
        
        // TKE缓冲区会自动处理保存，这里不需要手动保存
        if (this.buffer) {
            window.rLog('💾 TKE缓冲区将自动保存');
        } else {
            window.rError('❌ TKE缓冲区未初始化');
        }
    }
    
    // 公共API - 设置文件路径并加载内容
    async setFile(filePath) {
        try {
            // 创建TKE缓冲区
            this.buffer = new window.TKEEditorBuffer(filePath);
            await this.buffer.initialize();
            
            // 设置监听器
            this.buffer.addListener((eventType, data) => {
                this.handleBufferEvent(eventType, data);
            });
            
            // 加载文件内容
            await this.buffer.loadFromFile();
            
            window.rLog(`📁 EditorTab文件设置完成: ${filePath}`);
        } catch (error) {
            window.rError(`❌ EditorTab设置文件失败: ${error.message}`, error);
            throw error; // 重新抛出错误供上层处理
        }
    }
    
    // 处理缓冲区事件
    handleBufferEvent(eventType, data) {
        switch (eventType) {
            case 'loaded':
            case 'content-changed':
                this.render(); // 重新渲染
                break;
            case 'saved':
                window.rLog('💾 文件已保存');
                break;
        }
    }
    
    getValue() {
        if (!this.buffer) {
            window.rError('❌ TKE缓冲区未初始化');
            return '';
        }
        
        // 如果是文本模式且有DOM更改，先同步到缓冲区
        if (this.currentMode === 'text' && this.textContentEl) {
            const domContent = this.textContentEl.textContent || '';
            const bufferContent = this.buffer.getRawContent();
            
            if (domContent !== bufferContent) {
                window.rLog('📝 文本模式内容有变更，同步到缓冲区');
                // 异步更新缓冲区，但立即返回DOM内容
                this.buffer.updateFromText(domContent).catch(error => {
                    window.rError(`❌ 同步文本内容失败: ${error.message}`);
                });
                return domContent;
            }
        }
        
        // 从缓冲区获取最新内容
        const content = this.buffer.getRawContent();
        window.rLog(`📖 从TKE缓冲区获取内容长度: ${content.length}`);
        return content;
    }
    
    setPlaceholder(text) {
        // 实现占位符逻辑
    }
    
    insertText(text) {
        if (this.currentMode === 'text' && this.textContentEl) {
            // 在光标位置插入文本
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const textNode = document.createTextNode(text);
                range.insertNode(textNode);
                
                // 移动光标到插入文本的末尾
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                selection.removeAllRanges();
                selection.addRange(range);
                
                // 更新脚本模型
                const tksCode = this.textContentEl.textContent || '';
                this.script.fromTKSCode(tksCode);
                this.updateLineNumbers();
                this.triggerChange();
            } else {
                // 如果没有选区，追加到末尾
                this.textContentEl.textContent += text;
                this.script.fromTKSCode(this.textContentEl.textContent);
                this.updateLineNumbers();
                this.triggerChange();
            }
        }
    }
    
    focus() {
        if (this.currentMode === 'text' && this.textContentEl) {
            this.textContentEl.focus();
        }
    }
    
    on(event, callback) {
        this.listeners.push({ type: event, callback });
    }
    
    // 更新字体设置
    updateFontSettings(fontFamily, fontSize) {
        if (this.textContentEl) {
            this.textContentEl.style.fontFamily = fontFamily;
            this.textContentEl.style.fontSize = fontSize + 'px';
        }
        if (this.lineNumbersEl) {
            this.lineNumbersEl.style.fontFamily = fontFamily;
            this.lineNumbersEl.style.fontSize = fontSize + 'px';
        }
        // 更新CSS变量
        const root = document.documentElement;
        if (fontFamily !== 'var(--font-mono)') {
            root.style.setProperty('--font-mono', fontFamily);
        }
        root.style.setProperty('--font-size-editor', fontSize + 'px');
    }
    
    setTestRunning(isRunning, clearHighlight = false) {
        console.log('设置测试运行状态:', isRunning, '清除高亮:', clearHighlight, '当前模式:', this.currentMode);
        this.isTestRunning = isRunning;
        
        // 只有在明确要求清除高亮时才清除（成功完成时）
        if (!isRunning && clearHighlight) {
            console.log('测试成功结束，清除所有高亮');
            this.clearExecutionHighlight();
        } else if (!isRunning) {
            console.log('测试结束但保持错误高亮（如果有）');
        }
        
        // 更新状态指示器
        this.updateStatusIndicator();
        
        // 在文本模式下禁用/启用编辑
        if (this.currentMode === 'text' && this.textContentEl) {
            this.textContentEl.contentEditable = !isRunning;
            this.textContentEl.style.opacity = isRunning ? '0.7' : '1';
            this.textContentEl.style.cursor = isRunning ? 'not-allowed' : 'text';
        }
    }
    
    updateStatusIndicator() {
        console.log('更新状态指示器 - 运行状态:', this.isTestRunning, '当前模式:', this.currentMode);
        
        const statusBar = document.querySelector('.status-bar');
        const modeText = document.getElementById('editorModeText');
        
        if (!statusBar || !modeText) {
            console.error('找不到状态栏或模式文本元素');
            return;
        }
        
        // 清除所有模式类
        statusBar.classList.remove('status-bar-text-mode', 'status-bar-running');
        
        if (this.isTestRunning) {
            // 运行中状态
            modeText.textContent = '运行中';
            statusBar.classList.add('status-bar-running');
        } else if (this.currentMode === 'text') {
            // 文本编辑模式
            modeText.textContent = '文本编辑';
            statusBar.classList.add('status-bar-text-mode');
        } else {
            // 普通模式（块模式）
            modeText.textContent = '';
            // 不添加任何类，保持默认样式
        }
        
        console.log('状态栏已更新:', modeText.textContent || '普通模式');
    }
    
    createRunningIndicator() {
        // 在块模式下运行时，更新状态栏
        this.updateStatusIndicator();
        console.log('块模式运行指示器已更新到状态栏');
    }
    
    // 行高亮功能
    highlightExecutingLine(tksOriginalLineNumber) {
        console.log('=== 高亮请求开始 ===');
        console.log('TKS原始行号:', tksOriginalLineNumber);
        console.log('当前模式:', this.currentMode);
        console.log('上一次高亮行号:', this.currentHighlightedLine);
        console.log('测试运行状态:', this.isTestRunning);
        
        // 先检查这是否是一个有效的命令行
        let isValidCommandLine = false;
        if (this.script.originalLines && this.script.lineToCommandMap) {
            const originalLineIndex = tksOriginalLineNumber - 1;
            if (originalLineIndex >= 0 && originalLineIndex < this.script.lineToCommandMap.length) {
                isValidCommandLine = this.script.lineToCommandMap[originalLineIndex] !== null;
            }
        }
        
        if (!isValidCommandLine) {
            console.log('✓ 非命令行请求，保持当前高亮连续性');
            const originalLineIndex = tksOriginalLineNumber - 1;
            console.log('行内容:', this.script.originalLines ? `"${this.script.originalLines[originalLineIndex]}"` : '无法获取');
            console.log('=== 高亮请求结束（非命令行，保持当前高亮）===');
            return;
        }
        
        // 只有在切换到不同的有效命令行时才清除之前的高亮
        if (this.currentHighlightedLine !== tksOriginalLineNumber) {
            console.log('✓ 切换到新的命令行，清除之前的高亮');
            console.log('从行', this.currentHighlightedLine, '切换到行', tksOriginalLineNumber);
            this.clearExecutionHighlight();
            this.currentHighlightedLine = tksOriginalLineNumber;
        } else {
            console.log('✓ 同一命令行重复高亮请求，检查高亮是否仍然存在');
            
            // 检查当前高亮是否仍然存在
            let highlightExists = false;
            if (this.currentMode === 'text') {
                const existingHighlights = this.container.querySelectorAll('.line-highlight.executing');
                highlightExists = existingHighlights.length > 0;
                console.log('文本模式 - 现有执行高亮数量:', existingHighlights.length);
            } else if (this.currentMode === 'block') {
                const existingBlockHighlights = this.container.querySelectorAll('.workspace-block.highlighted.executing');
                highlightExists = existingBlockHighlights.length > 0;
                console.log('块模式 - 现有执行高亮数量:', existingBlockHighlights.length);
            }
            
            if (highlightExists) {
                console.log('✓ 高亮仍然存在，跳过重新创建');
                console.log('=== 高亮请求结束（跳过）===');
                return;
            } else {
                console.log('✗ 高亮丢失，重新创建');
            }
        }
        
        if (this.currentMode === 'text' && this.textContentEl) {
            // 文本模式：将TKS原始行号转换为显示行号
            const displayLineNumber = this.calculateDisplayLineNumber(tksOriginalLineNumber);
            console.log('文本模式 - 计算显示行号:', displayLineNumber);
            if (displayLineNumber > 0) {
                this.addLineHighlight(displayLineNumber, 'executing');
                console.log('✓ 文本模式高亮已创建 - 显示行号:', displayLineNumber, '(TKS原始行号:', tksOriginalLineNumber, ')');
                console.log('=== 高亮请求结束（文本模式完成）===');
            } else {
                console.error('✗ 有效命令行但显示行号计算失败:', displayLineNumber);
                console.log('=== 高亮请求结束（文本模式失败）===');
            }
        } else if (this.currentMode === 'block') {
            // 块模式：将TKS原始行号转换为命令索引（已确认是有效命令行）
            const originalLineIndex = tksOriginalLineNumber - 1;
            const commandIndex = this.script.lineToCommandMap[originalLineIndex];
            console.log('块模式 - TKS行号', tksOriginalLineNumber, '映射到命令索引:', commandIndex);
            
            // 命令索引转换为1基索引进行高亮
            const blockIndex = commandIndex + 1;
            this.highlightExecutingBlock(blockIndex, 'executing');
            console.log('✓ 块模式高亮已创建 - 块索引:', blockIndex, '(命令索引:', commandIndex, ')');
            console.log('=== 高亮请求结束（块模式完成）===');
        } else {
            console.warn('高亮条件不满足:', {
                currentMode: this.currentMode,
                hasTextContentEl: !!this.textContentEl,
                hasBlocksContainer: !!this.blocksContainer
            });
        }
    }
    
    highlightErrorLine(tksOriginalLineNumber) {
        console.log('收到错误高亮请求 - TKS原始行号:', tksOriginalLineNumber, '当前模式:', this.currentMode);
        
        // 不清除之前的高亮，直接转换为错误高亮
        
        if (this.currentMode === 'text' && this.textContentEl) {
            // 文本模式：将TKS原始行号转换为显示行号
            const displayLineNumber = this.calculateDisplayLineNumber(tksOriginalLineNumber);
            console.log('文本模式 - 计算错误显示行号:', displayLineNumber);
            if (displayLineNumber > 0) {
                // 先清除执行高亮，然后添加错误高亮
                this.clearExecutionHighlight();
                this.addLineHighlight(displayLineNumber, 'error');
                console.log('文本模式高亮错误行:', displayLineNumber, '(TKS原始行号:', tksOriginalLineNumber, ')');
            } else {
                console.warn('无效的错误显示行号:', displayLineNumber);
            }
        } else if (this.currentMode === 'block') {
            // 块模式：将TKS原始行号转换为命令索引
            if (!this.script.originalLines || !this.script.lineToCommandMap) {
                console.warn('缺少行号映射数据');
                return;
            }
            
            const originalLineIndex = tksOriginalLineNumber - 1;
            if (originalLineIndex >= 0 && originalLineIndex < this.script.lineToCommandMap.length) {
                const commandIndex = this.script.lineToCommandMap[originalLineIndex];
                console.log('块模式 - TKS错误行号', tksOriginalLineNumber, '映射到命令索引:', commandIndex);
                
                if (commandIndex !== null) {
                    // 先清除执行高亮，然后添加错误高亮
                    this.clearExecutionHighlight();
                    const blockIndex = commandIndex + 1;
                    this.highlightExecutingBlock(blockIndex, 'error');
                    console.log('块模式高亮错误块:', blockIndex, '(命令索引:', commandIndex, ')');
                } else {
                    console.warn('TKS错误行号不是命令行:', tksOriginalLineNumber);
                }
            } else {
                console.warn('TKS错误行号超出范围:', tksOriginalLineNumber);
            }
        } else {
            console.warn('错误高亮条件不满足:', {
                currentMode: this.currentMode,
                hasTextContentEl: !!this.textContentEl,
                hasBlocksContainer: !!this.blocksContainer
            });
        }
    }
    
    // 计算显示行号：将TKS引擎的原始行号转换为编辑器中显示的行号
    calculateDisplayLineNumber(tksOriginalLineNumber) {
        console.log('计算显示行号 - TKS引擎原始行号:', tksOriginalLineNumber);
        console.log('脚本模型信息:', {
            originalLines: this.script.originalLines ? this.script.originalLines.length : '无',
            commands: this.script.commands.length,
            mapping: this.script.lineToCommandMap ? this.script.lineToCommandMap.length : '无'
        });
        
        if (!this.textContentEl || !this.script.originalLines) {
            console.warn('缺少必要的数据');
            return -1;
        }
        
        // TKS引擎报告的是基于原始文本的行号(1基索引)，需要转换为0基索引
        const originalLineIndex = tksOriginalLineNumber - 1;
        
        // 检查原始行号是否有效
        if (originalLineIndex < 0 || originalLineIndex >= this.script.originalLines.length) {
            console.warn('TKS原始行号超出范围:', tksOriginalLineNumber, '有效范围: 1-' + this.script.originalLines.length);
            return -1;
        }
        
        // 从映射中查找对应的命令索引
        const commandIndex = this.script.lineToCommandMap[originalLineIndex];
        console.log('原始行号', tksOriginalLineNumber, '映射到命令索引:', commandIndex);
        
        if (commandIndex === null) {
            console.warn('原始行号不是命令行:', tksOriginalLineNumber);
            return -1;
        }
        
        // 现在需要在显示的文本中找到这个命令对应的行
        const lines = this.textContentEl.textContent.split('\n');
        let stepsStartLine = -1;
        
        // 找到"步骤:"行
        for (let i = 0; i < lines.length; i++) {
            if (lines[i].trim() === '步骤:') {
                stepsStartLine = i + 1;
                break;
            }
        }
        
        if (stepsStartLine === -1) {
            console.warn('未找到步骤行');
            return -1;
        }
        
        // 在步骤区域中找到第N个命令行
        let foundCommandCount = 0;
        for (let i = stepsStartLine; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line || line.startsWith('#') || 
                line.startsWith('用例:') || line.startsWith('脚本名:') ||
                line === '详情:' || line === '步骤:' ||
                line.includes('appPackage:') || line.includes('appActivity:')) {
                continue;
            }
            
            // 这是一个命令行
            if (foundCommandCount === commandIndex) {
                const displayLine = i + 1;
                console.log('找到显示行号:', displayLine, '(原始行号:', tksOriginalLineNumber, '命令索引:', commandIndex, ')');
                return displayLine;
            }
            foundCommandCount++;
        }
        
        console.warn('未找到对应的显示行号');
        return -1;
    }
    
    clearExecutionHighlight() {
        console.log('清除执行高亮');
        this.currentHighlightedLine = null; // 重置当前高亮行号
        
        // 文本模式：清除行高亮
        if (this.currentMode === 'text') {
            // 从文本编辑器容器和内容元素中移除所有行高亮
            const containers = [this.textContentEl, this.textContentEl?.parentElement, this.editorContainer];
            containers.forEach(container => {
                if (container) {
                    const existingHighlights = container.querySelectorAll('.line-highlight');
                    console.log(`从 ${container.className} 中移除 ${existingHighlights.length} 个高亮元素`);
                    existingHighlights.forEach(highlight => highlight.remove());
                }
            });
            
            // 移除行号高亮
            if (this.lineNumbersEl) {
                const highlightedLineNumbers = this.lineNumbersEl.querySelectorAll('.line-number.highlighted');
                highlightedLineNumbers.forEach(lineNum => {
                    lineNum.classList.remove('highlighted', 'executing', 'error');
                });
                console.log(`移除了 ${highlightedLineNumbers.length} 个行号高亮`);
            }
        }
        
        // 块模式：清除块高亮
        if (this.currentMode === 'block' && this.blocksContainer) {
            const highlightedBlocks = this.blocksContainer.querySelectorAll('.workspace-block.highlighted');
            highlightedBlocks.forEach(block => {
                block.classList.remove('highlighted', 'executing', 'error');
                block.style.boxShadow = '';
                block.style.transform = '';
                block.style.animation = '';
                
                // 移除高亮覆盖层
                const overlays = block.querySelectorAll('.block-highlight-overlay');
                overlays.forEach(overlay => overlay.remove());
            });
            console.log(`移除了 ${highlightedBlocks.length} 个块高亮`);
        }
        
        console.log('已清除所有高亮');
    }
    
    // 块模式高亮功能
    highlightExecutingBlock(commandIndex, type) {
        console.log('块模式高亮请求:', commandIndex, type, '容器存在:', !!this.blocksContainer);
        
        if (!this.blocksContainer) {
            console.warn('blocksContainer不存在');
            return;
        }
        
        const blocks = this.blocksContainer.querySelectorAll('.workspace-block.command-block');
        console.log('找到块数量:', blocks.length, '目标索引:', commandIndex - 1);
        
        if (commandIndex >= 1 && commandIndex <= blocks.length) {
            const targetBlock = blocks[commandIndex - 1]; // 转换为0基索引
            if (targetBlock) {
                // 添加高亮类
                targetBlock.classList.add('highlighted', type);
                
                // 创建高亮覆盖层，而不是直接修改块的样式
                const highlightOverlay = document.createElement('div');
                highlightOverlay.className = `block-highlight-overlay ${type}`;
                highlightOverlay.style.cssText = `
                    position: absolute !important;
                    top: -2px !important;
                    left: -2px !important;
                    right: -2px !important;
                    bottom: -2px !important;
                    border-radius: 10px !important;
                    pointer-events: none !important;
                    z-index: 5 !important;
                    transition: all 0.2s ease !important;
                `;
                
                if (type === 'executing') {
                    highlightOverlay.style.cssText += `
                        border: 3px solid #ffc107 !important;
                        background: rgba(255, 193, 7, 0.1) !important;
                        box-shadow: 0 0 12px rgba(255, 193, 7, 0.4), inset 0 0 12px rgba(255, 193, 7, 0.1) !important;
                    `;
                } else if (type === 'error') {
                    highlightOverlay.style.cssText += `
                        border: 3px solid #dc3545 !important;
                        background: rgba(220, 53, 69, 0.1) !important;
                        box-shadow: 0 0 12px rgba(220, 53, 69, 0.4), inset 0 0 12px rgba(220, 53, 69, 0.1) !important;
                    `;
                }
                
                // 确保目标块有相对定位
                if (!targetBlock.style.position) {
                    targetBlock.style.position = 'relative';
                }
                
                // 添加覆盖层到块中
                targetBlock.appendChild(highlightOverlay);
                
                // 添加脉搏效果
                if (type === 'executing') {
                    targetBlock.style.animation = 'pulse-executing 2s infinite';
                }
                
                // 滚动到可见区域
                setTimeout(() => {
                    targetBlock.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }, 100);
                
                console.log('块模式高亮已添加:', commandIndex, type, '覆盖层已添加到块中');
            } else {
                console.warn('找不到目标块:', commandIndex - 1);
            }
        } else {
            console.warn('无效的块索引:', commandIndex, '有效范围: 1-' + blocks.length);
        }
    }
    
    addLineHighlight(lineNumber, type) {
        console.log('添加行高亮:', lineNumber, type);
        
        // 高亮行号
        if (this.lineNumbersEl) {
            const lineNumbers = this.lineNumbersEl.querySelectorAll('.line-number');
            console.log('行号元素数量:', lineNumbers.length, '目标行号:', lineNumber - 1);
            if (lineNumbers[lineNumber - 1]) {
                lineNumbers[lineNumber - 1].classList.add('highlighted', type);
                console.log('行号高亮已添加');
            } else {
                console.warn('找不到行号元素:', lineNumber - 1);
            }
        } else {
            console.warn('lineNumbersEl不存在');
        }
        
        // 在文本内容上添加高亮背景
        if (!this.textContentEl) {
            console.warn('textContentEl不存在，无法添加高亮');
            return;
        }
        
        // 确保容器有正确的定位
        const textWrapper = this.textContentEl.parentElement;
        if (textWrapper && !textWrapper.style.position) {
            textWrapper.style.position = 'relative';
        }
        
        const lineHeight = 21; // 与CSS中的line-height保持一致
        const topOffset = 16; // 与padding-top保持一致
        
        const highlightDiv = document.createElement('div');
        highlightDiv.className = `line-highlight ${type}`;
        highlightDiv.style.cssText = `
            position: absolute !important;
            left: 0 !important;
            right: 0 !important;
            height: ${lineHeight}px !important;
            top: ${topOffset + (lineNumber - 1) * lineHeight}px !important;
            background: ${type === 'executing' ? 'rgba(255, 193, 7, 0.3)' : 'rgba(220, 53, 69, 0.3)'} !important;
            border-left: 3px solid ${type === 'executing' ? '#ffc107' : '#dc3545'} !important;
            pointer-events: none !important;
            z-index: 10 !important;
            margin: 0 !important;
            padding: 0 !important;
        `;
        
        // 添加到文本编辑器的包装器而不是内容元素
        const targetContainer = textWrapper || this.textContentEl;
        targetContainer.appendChild(highlightDiv);
        
        // 滚动到高亮行
        setTimeout(() => {
            const lineNumberEl = this.lineNumbersEl?.querySelectorAll('.line-number')[lineNumber - 1];
            if (lineNumberEl) {
                lineNumberEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
        
        console.log('文本高亮已添加到:', targetContainer.className);
        console.log('高亮div样式:', highlightDiv.style.cssText);
        console.log('高亮div实际父元素:', highlightDiv.parentElement);
    }
    
    removeStatusIndicator() {
        // 清理状态栏状态
        const statusBar = document.querySelector('.status-bar');
        const modeText = document.getElementById('editorModeText');
        
        if (statusBar) {
            statusBar.classList.remove('status-bar-text-mode', 'status-bar-running');
        }
        
        if (modeText) {
            modeText.textContent = '';
        }
        
        // 清理可能存在的所有旧的内联状态指示器（用于兼容）
        const indicators = document.querySelectorAll('.editor-status-indicator');
        indicators.forEach(indicator => indicator.remove());
        
        // 从编辑器视图中移除内联指示器
        if (this.editorContainer) {
            const textEditorView = this.editorContainer.querySelector('.text-editor-view');
            if (textEditorView) {
                const indicator = textEditorView.querySelector('.editor-status-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }
    }

    destroy() {
        clearTimeout(this.saveTimeout);
        // 不再需要移除全局快捷键监听器，因为它在 EditorManager 中
        this.removeStatusIndicator();
        this.hideCommandMenu();
        this.hideContextMenu();
        
        // 清理拖拽监听器
        if (this.dragOverHandler) {
            this.blocksContainer.removeEventListener('dragover', this.dragOverHandler);
        }
        if (this.dragLeaveHandler) {
            this.blocksContainer.removeEventListener('dragleave', this.dragLeaveHandler);
        }
        if (this.dropHandler) {
            this.blocksContainer.removeEventListener('drop', this.dropHandler);
        }
        
        this.listeners = [];
    }
}

// 旧的ScriptModel已被TKEEditorBuffer完全替代，所有.tks解析和处理都由TKE负责

// 导出到全局
window.EditorTab = EditorTab;
